---
description: 
globs: 
alwaysApply: false
---
---
description:
globs:
alwaysApply: false
---
# MCP Development Guide with Node.js, Nest.js, and TypeScript

## Key Principles
- Use TypeScript for type safety and better development experience
- Follow a modular architecture with clear separation of concerns
- Implement clean code practices with meaningful variable and function names
- Use async/await for handling asynchronous operations
- Leverage functional programming where appropriate
- Implement comprehensive error handling and logging

## TypeScript Best Practices
- Use strict type checking with `"strict": true` in tsconfig.json
- Prefer interfaces for object shapes and types for unions/primitives
- Use proper typing for functions, parameters, and return values
- Leverage TypeScript's utility types (Partial, Pick, Omit, etc.)
- Use enums for fixed sets of values
- Create reusable type definitions in dedicated files

## Node.js Development
- Use the latest LTS version of Node.js
- Implement proper error handling with try/catch blocks
- Use environment variables for configuration (dotenv)
- Implement logging with structured formats (winston/pino)
- Use proper stream handling for file operations
- Implement graceful shutdown handlers for process termination

## Nest.js Architecture
- Use modules to organize code into cohesive units
- Implement providers as services for business logic
- Use controllers to handle HTTP requests
- Leverage dependency injection for loose coupling
- Use pipes for input validation and transformation
- Implement guards for authentication and authorization
- Use interceptors for cross-cutting concerns
- Create custom decorators for repeated patterns

## MCP (Model Context Protocol) Implementation
- Follow the MCP specification for interoperability
- Implement proper WebSocket handling for real-time communication
- Structure message payloads according to MCP standards
- Handle reconnection logic for WebSocket connections
- Implement message queuing for reliability
- Use proper serialization/deserialization for messages
- Implement heartbeat mechanisms for connection health

## Project Structure
```
project/
├── src/
│   ├── config/           # Configuration files and environment setup
│   ├── controllers/      # Request handlers
│   ├── dto/              # Data Transfer Objects
│   ├── interfaces/       # TypeScript interfaces
│   ├── services/         # Business logic
│   ├── models/           # Data models
│   ├── utils/            # Utility functions
│   ├── middleware/       # Custom middleware
│   ├── mcp/              # MCP-specific implementation
│   │   ├── client.ts     # MCP client implementation
│   │   ├── server.ts     # MCP server implementation
│   │   ├── types.ts      # MCP-specific types
│   │   └── handlers/     # MCP message handlers
│   └── main.ts           # Application entry point
├── test/                 # Tests
├── dist/                 # Compiled output
├── node_modules/         # Dependencies
├── package.json          # Package configuration
├── tsconfig.json         # TypeScript configuration
└── README.md             # Documentation
```

## WebSocket Communication
- Use `ws` or `socket.io` for WebSocket connections
- Implement proper message framing and parsing
- Handle connection errors and reconnection logic
- Implement message acknowledgment mechanisms
- Use proper event handlers for WebSocket lifecycle

## Error Handling
- Implement centralized error handling
- Use custom error classes for different error types
- Include proper error codes and messages
- Log errors with appropriate severity levels
- Return consistent error responses to clients

## Testing
- Write unit tests for business logic
- Implement integration tests for API endpoints
- Use mocks for external dependencies
- Implement WebSocket testing strategies
- Use Jest or Mocha for test frameworks
- Implement proper test coverage reporting

## Deployment and DevOps
- Use Docker for containerization
- Implement CI/CD pipelines
- Configure proper health checks
- Implement monitoring and alerting
- Use environment-specific configurations

## Security Considerations
- Implement proper authentication and authorization
- Validate all input data
- Use HTTPS for all communications
- Implement rate limiting
- Follow security best practices for Node.js
- Keep dependencies updated

## Performance Optimization
- Implement proper caching strategies
- Use connection pooling for databases
- Optimize WebSocket message sizes
- Implement pagination for large data sets
- Use worker threads for CPU-intensive tasks
- Implement proper load balancing

## MCP Specific Guidelines
- Follow the MCP specification closely
- Implement proper versioning for MCP messages
- Handle disconnections and reconnections gracefully
- Implement proper error propagation through MCP
- Use proper serialization formats (JSON)
- Implement proper logging for MCP messages
